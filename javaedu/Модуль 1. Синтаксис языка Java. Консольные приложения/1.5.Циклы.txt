Здравствуй, дорогой друг!

Ты приступаешь к изучению темы «Циклы».

Изучение данной темы будет проводиться в формате онлайн-уроков.

Онлайн-уроки по этой теме состоятся 05.11.2022, 09.11.2022, 12.11.2022, 16.11.2022, 19.11.2022.

Важной алгоритмической конструкцией любого языка программирования является цикл.

Есть несколько типов циклов, с которыми ты уже знаком по языку С, в языке программирования Java они такие же.

На онлайн-уроках мы будем использовать самый простой тип цикла — цикл с параметром «for».

Ты научишься выполнять однотипные операции сразу над целым диапазоном чисел и использовать цикл для расчёта статистических величин. А также узнаешь, как вложенные циклы помогают решать довольно сложные многомерные математические задачи всего в несколько строк кода.

1. Создай новый проект с именем «Counter», а в нём создай класс с именем «myClass».

2. Напиши программу, которая выводит любую фразу, например, «Привет!», но не сразу, а после последовательного отображения чисел от 1 до 10, как показано ниже:


Алгоритм, отображающий последовательность цифр, оформи в виде функции с именем «Counter» (пер. с англ. счётчик). Причём у неё должно быть два аргумента: от какой и до какой цифры считать.

В результате метод «main» должен выглядеть следующим образом:

	public static void main(String[] args) {
	    Counter(1, 10);
	    System.out.println("Привет!");
	}
Примечание: счётчик в функции «Counter» следует реализовать с помощью цикла «for».

Хоть ты с ним уже и знаком, повторим ещё раз.

Цикл — это программная конструкция, которая выполняется многократно, пока справедливо некоторое условие (или набор условий).

Операторы, находящиеся внутри цикла, называются телом цикла, а каждое выполнение тела цикла называется итерацией (т. е. цикл состоит из нескольких итераций).

Наиболее простой цикл — это цикл с параметром. В нём заранее известны диапазон перебора значений и шаг, с которым они будут перебираться.

В синтаксисе языка Java цикл с параметром записывается следующим образом:

	for ( <инициализация>; <условие завершения цикла>; <шаг> ) {
	    <тело цикла>;
	}
Инициализация выполняется один раз (переменной нужного типа присваивается начальное значение), затем проверяется условие завершения цикла, которое должно быть булевым выражением. Это условие проверяется перед каждой итерацией, и пока оно ложно, тело цикла будет выполняться.

Переменная, указанная при инициализации цикла, называется переменной цикла. Эта переменная должна присутствовать как в условии завершения цикла, так и при указании шага, например:

	for ( int i=1 ; i<10; i=i+2 ) {
	    <тело цикла>;
	}
В этом примере переменная цикла примет следующие значения: 1, 3, 5, 7, 9, то есть на каждом шаге она увеличивается на 2. Это и есть шаг цикла.

Тело цикла заключается в фигурные скобки. И все переменные, объявленные в теле цикла, «видны» только в нём.

Примечание: если тело цикла состоит из одного оператора, то фигурные скобки можно опустить.

Переменную цикла можно объявлять внутри раздела инициализации оператора «for». Переменная, объявленная внутри оператора «for», также «видна» только внутри тела цикла.

Если у тебя возникли затруднения в написании кода, можешь просмотреть полный код функции:


1. Запусти программу на выполнение и проверь её работоспособность.

После запуска программы цифры появляются сразу (цикл отрабатывает практически мгновенно). Давай сделаем так, чтобы цифры появлялись с паузой, увеличим время ожидания пользователя перед появлением финального текста!

За паузу отвечает метод «sleep», который находится в классе «Thread», поэтому не забудь импортировать нужный класс в проект. Методу передаётся целое число, которое задаёт паузу в миллисекундах. Код задания паузы выглядит следующим образом:

	try {
	    Thread.sleep(pause);
	} catch (InterruptedException e) {}
Здесь «pause» — переменная целочисленного типа.

Примечание: метод «sleep» должен быть обязательно «обёрнут» в специальный блок «try ... catch», который будет рассмотрен позже. Использование этого блока связано с тем, что применение методов из класса «Thread» может вызывать ошибку во время работы программы (то есть создать исключение), а конструкция «try ... catch» имеет инструментарий для «ловли» таких ошибок.

2. Модифицируй функцию «Counter» так, чтобы цифры появлялись с заданной паузой. Значение паузы должно передаваться в параметрах функции и задаваться в миллисекундах.

3. Добавь ещё один аргумент при вызове функции. В результате метод «main» может выглядеть следующим образом (пауза равна 1 секунде):


Запусти программу на выполнение и проверь её работоспособность.

Теперь цифры появляются с задержкой, но что-то выглядит неестественно... Ведь отсчёт обычно не увеличивает значение числа, а уменьшает. Скажем от 10 до 1.

Изменить направление счёта не представляется большой проблемой. Достаточно изменить параметры цикла следующим образом (изменения выделены цветом):

for (int i = start; i >= end; i--)

Теперь переменная цикла «i» будет уменьшаться на 1 до тех пор, пока она больше или равна значению переменной «end».

В таком случае и в методе «Counter» первый параметр должен быть больше второго:

	Counter(10, 1, 1000);
Но вот в чём проблема... Если в программе нужно как уменьшение, так и увеличение счётчика, то придётся писать две функции. Причём эти функции будут отличаться только параметрами цикла, как показано выше.

Гораздо компактней и универсальней (что весьма приветствуется при написании программ) создать одну функцию, которая бы считала в любом направлении!

Эту проблему унификации можно решать различными способами. Опишем наиболее прозрачный алгоритм:

1. Сам цикл не меняется, он всегда будет считать от меньшего к большему.

2. Если начальное число больше конечного, то перед циклом необходимо просто поменять их местами и запомнить направление счёта (например, в переменную логического типа). Пусть это будет переменная с именем «isRevers». Если она равна «false», то начальное значение меньше конечного, в противном случае значение равно «true»:

	boolean isRevers = false;
	if (start > end){
	    int temp = start;
	    start = end;
        end = temp;
        isRevers = true;
	}
Примечание: обмен значениями осуществлён с помощью вспомогательной переменной с именем «temp».

Далее нужно выполнить следующие шаги:

1. Рассчитать значение счётчика на основе значения переменной «isRevers» и занести его в отдельную переменную, например, с именем «result».

2. Если «isRevers» = «false», то в переменную «result» заносится непосредственно переменная цикла.

3. Если «isRevers» = «true», то в переменную «result» заносится разность между максимальным значением и значением переменной цикла (для организации обратного отсчёта):

	int result = i;
	if (isRevers)
	    result = end - i + 1;
Понятно?

Модифицируй функцию «Counter», чтобы она «считала» как от большего к меньшему, так и от меньшего к большему:


Запусти программу на выполнение и проверь её работоспособность, задавая различные начальные и конечные значения, например, следующие: 0 ... 10; −5 ... 5; 20 ...15; 3 ... −10; −10 ... −20.

Обычно цикл организовывают в том случае, когда над заданным диапазоном значений нужно провести однотипные вычислительные операции.

1. Создай новый проект, а в нём создай класс с именем «myClass».

2. Напиши программу, которая отображает результат умножения чисел из заданного диапазона (например, от 1 до 10) на два. Отображение результата на экране должно быть в следующем формате:


Запусти программу на выполнение и проверь её работоспособность.

Если у тебя возникли затруднения, посмотри код, реализующий этот алгоритм:


Задача очень простая! Но чаще встречаются задачи, в которых вычислительные операции нужно применить только к части диапазона, перебираемого циклом. Либо к одной части диапазона нужно применить одни операции, а к другой части диапазона — другие.

1. Модифицируй программу так, чтобы умножались на 2 только числа, кратные трём, а остальные числа умножались на 3. Результат работы программы показан ниже:


Примечание: для проверки на кратность, используй операцию «%».

2. Запусти программу на выполнение и проверь её работоспособность.

Если у тебя возникли затруднения, посмотри правильный код:


Теперь разработаем небольшую статистическую программу.

Статистика — это отрасль знаний, в которой излагаются общие вопросы сбора, измерения и анализа массовых статистических (количественных или качественных) данных.

И циклы — это основной инструмент получения статистических данных.

В большинстве случаев на основе набора каких-то чисел (данных) необходимо получить некоторые статистические величины (числа), характеризующие этот набор. Рассмотрим наиболее часто используемые статистические величины:

1. Среднее арифметическое чисел. Используется, например, для расчёта средней оценки успеваемости.

2. Сумма чисел. Может использоваться, например, для подсчёта общей массы каких-то объектов.

Напишем программу, которая запрашивает у пользователя ввод вещественных чисел, а затем выводит их сумму и среднее арифметическое

1. Создай новый проект, а в нём создай класс с именем «myClass».

2. Напиши программу. Ниже показан пример работы программы:


Обрати внимание, количество чисел также должно вводиться с клавиатуры. Для ввода чисел используй уже готовую процедуру «InputNumber», написанную в предыдущем уроке (скопируй её в текущий проект).

Вначале должен быть запрос на ввод количества чисел:

	int count = (int) InputNumber("Введите количество чисел: ");
Примечание: так как количество чисел — это целочисленное значение, а функция возвращает вещественный тип, то необходимо приведение типа к целому, о чём говорит запись «int» перед функцией.

А затем нужно организовать цикл на ввод данных:

	double sum = 0;
	for (int i = 1; i <= count; i = i + 1) {
	    double number = InputNumber("Введите " + i + " число: ");
        sum += number;
	}
Примечание: обрати внимание, что значение суммы накапливается сразу в цикле, в переменную «sum», т. к. значение в переменной «number» постоянно обновляется.

Вывод полученных статистических значений в консоль оформляется следующим образом:

	System.number.println("---");
	System.number.println("Сумма: " + sum);
	System.number.println("Среднее арифметическое: " + sum / count);
Примечание: для получения среднестатистического значения необходимо сумму чисел разделить на их количество.

3. Запусти программу на выполнение и проверь её работоспособность.

Если у тебя возникли затруднения в написании программы, можешь просмотреть её полный код:


В нашем мире редко встретишь одномерный набор данных. Обычно данные представлены многомерными структурами. Для обработки таких данных циклы могут вкладываться друг в друга как матрёшки.

Вложенный цикл по отношению к циклу, в тело которого он вложен, будет именоваться внутренним циклом, и наоборот, цикл, в теле которого существует вложенный цикл, будет именоваться внешним по отношению к вложенному.

Внутрь вложенного цикла в свою очередь может быть вложен ещё один цикл, образуя следующий уровень вложенности и так далее. Количество уровней вложенности, как правило, не ограничивается.

Ниже приведён пример кода, печатающий в консоли таблицу умножения:


Программа состоит из двух вложенных циклов. Внешний цикл выделен зелёным прямоугольником, а внутренний — красным. Причём переменная цикла «j» «видна» только внутреннему циклу. Во внешнем цикле, после печати строки, печатается служебный символ для перехода на следующую строку в консоли (8-я строка в коде).

После выполнения кода получим следующий результат:

1 2 3 4 5 6 7 8 9
2 4 6 8 10 12 14 16 18
3 6 9 12 15 18 21 24 27
4 8 12 16 20 24 28 32 36
5 10 15 20 25 30 35 40 45
6 12 18 24 30 36 42 48 54
7 14 21 28 35 42 49 56 63
8 16 24 32 40 48 56 64 72
9 18 27 36 45 54 63 72 81

Вкладывать циклы друг в друга мы научились еще при изучении языка С, поэтому реализация следующей программы не должна вызвать затруднений.

Рассмотрим уравнение, для которого нужно найти корни в заданном диапазоне изменения его аргументов:

a2 + b3 = c4

Видно, что в уравнении присутствуют три аргумента и найти его корни весьма сложно.

Самый простой способ решения — это перебрать все возможные значения аргументов a, b и c в заданном диапазоне чисел и посмотреть, при каких из них будет выполняться равенство.

Примечание: в методах численной математики такой способ называется методом перебора.

Попробуем воспользоваться именно этим способом.

1. Создай новый проект, а в нём создай класс с именем «myClass».

2. Напиши программу, которая будет решать вышеприведённое уравнение в заданном диапазоне изменения аргументов (скажем, от 1 до 1000).

Для этого нужно организовать три вложенных цикла, а в теле самого «глубокого» вычислять равенство, и если оно выполняется, то выводить значения аргументов:

	for (int i = 1; i <= 1000; i++)
	    for (int j = 1; j <= 1000; j++)
	        for (int k = 1; k <= 1000; k++)
	            if ( i*i + j*j*j == k*k*k*k )
	                System.out.println(i +" | "+ j + " | " + k);
Примечание: исторически сложилось, что переменным циклов «for» обычно даются названия «i», «j», k". Хотя на самом деле, имена могут быть любыми. В данном примере логичней даже было бы переменным циклов дать имена аргументов уравнения — a, b, c.

3. Запусти программу на выполнение и проверь её работоспособность. Ты должен получить следующий результат:


Итак, программа напечатала несколько строк решения уравнения. В столбцах находятся значения аргументов (a, b, c соответственно), при которых выполняется равенство.

Несмотря на то, что программа выдала верный результат, внешний вид оставляет желать лучшего.

4. Выровняй столбцы аргументов по левому краю, а также подпиши их, как показано на рисунке ниже:


Примечание: выравнивание осуществляется с помощью управляющей последовательности «\t».

Если у тебя возникли затруднения в написании программы, можешь просмотреть полный код метода «main»:


А теперь переходи к выполнению самостоятельных заданий!

Циклы с постусловием и предусловием

Цикл «for» используется, когда заранее известен шаг переменной цикла, а при достижении переменной цикла некоего значения цикл должен завершить свою работу. Если же шаг цикла не должен быть постоянным, или цикл должен завершаться только при соблюдении некоторых условий, только косвенно зависящих от переменной цикла, используются более универсальные циклы: цикл с предусловием и цикл с постусловием.

В этом уроке ты продолжишь работу с циклами и познакомишься со способами досрочного прерывания циклов при необходимости. Досрочное прерывание цикла часто повышает производительность программ и делает их более гибкими.

В предыдущих уроках ты написал функцию «InputNumber», которая запрашивает у пользователя вещественное число. И если пользователь ввёл что-то, отличное от числа, то функция отображает на экране надпись «Неверный ввод», и программа завершает свою работу.

С точки зрения пользователя, это очень неудобно. Ведь если программа попросит ввести подряд несколько чисел, а пользователь вдруг ошибся с вводом последнего, то он будет очень долго вспоминать разработчиков «ласковыми» словами.

1. Усовершенствуй функцию «InputNumber» так, чтобы она запрашивала ввод данных до тех пор, пока пользователь не введёт их корректно. Сделай это в каком-то одном проекте, а затем скопируй функцию во все проекты, где она используется.

Для создания такой функциональности нужно использовать цикл с постусловием.

Ты уже знаешь, что для выполнения тела цикла по крайней мере один раз, даже в том случае, когда логическое выражение с самого начала принимает значение false", используется циклическая конструкция с постусловием (условие проверяется после выполнения тела цикла).

Общая форма записи цикла с постусловием следующая:

	<инициализация>;
	do {
	    <тело цикла с изменением переменной цикла>
	} while ( <условие завершения цикла> );
Этот цикл многократно выполняется до тех пор, пока значение логического выражения в условии равно «false», причём:

инициализация переменной цикла осуществляется перед циклом;
изменение значения переменной автоматически в цикле не предусмотрено (как у цикла с параметром), и программист должен не забыть прописать в теле цикла оператор, изменяющий переменную цикла.
Примечание: если ты забыл об изменении переменной цикла внутри тела цикла, то получишь бесконечный цикл.

В усовершенствованной функции «InputNumber» ввод данных должен быть «обёрнут» в цикл с постусловием, и выход из этого цикла должен быть только тогда, когда функция «hasNextDouble» вернёт значение «false».

Полный код функции:


Так как проверка на ошибку проводится в двух местах (в теле цикла и в условии цикла), то удобней занести результат проверки в логическую переменную «isError». Эта переменная объявлена перед циклом, т. к. она участвует в проверке условия выхода из цикла и должна быть «видна» ему.

Если пользователь ввёл неверные данные, то программа выполнит тело условия: отобразит предупреждающую надпись и «впустую» считает данные из потока ввода, т. е. фактически очистит память для дальнейшего ввода.

Если пользователь ввёл верные данные, то цикл завершится, и данные вернутся в основную программу.

Обрати внимание, что переменной цикла является переменная «isError», а шаг цикла (как это было в цикле «for») отсутствует. Пользователь просто вводит данные до тех пор, пока переменная цикла равна «true». И этот процесс ввода может быть бесконечным, чего нельзя было достичь, используя цикл «for».

2. Запусти на выполнение программы, где используется функция, и проверь их работоспособность.

Теперь ты получил функцию ввода вещественных чисел с более удобным контролем неправильного ввода.

Циклы с пост- и предусловием часто используются там, где нельзя точно сказать, когда из цикла необходимо выйти.

Давай смоделируем вполне реальную ситуацию.

Некий контейнер способен выдержать определённую массу (обозначим её как «maxMass»). И в этот контейнер по транспортной ленте сбрасываются детали, которые заранее взвешиваются (вес детали в нашем случае вводится с клавиатуры). Задача: не допустить перегрузки контейнера и выключить ленту, когда масса деталей в нём превысит «maxMass».

Детали взвешиваются перед сбросом в контейнер. Если с очередной деталью вес превышает «maxMass», то транспортная лента останавливается:


1. Создай новый проект, а в нём создай класс с именем «myClass».

2. Напиши программу, которая запрашивает у пользователя массу очередной детали и заканчивает свою работу, когда общая масса больше заданной величины. Пример работы программы показан ниже:


Вначале тебе нужно объявить переменную «maxMass»:

	double maxMass = 100;
Хотя она и будет участвовать только в условии, но будет полезно иметь быстрый доступ к её значению, чтобы потом не «копаться» в коде, когда нужно будет поменять это значение.

Основой алгоритма будет цикл с постусловием (т. к. ввод массы должен произойти хотя бы один раз). Переменная «maxMass» будет сравниваться с переменной цикла «sumMass», которая должна быть инициализирована перед циклом. Эта переменная будет накапливать сумму масс деталей:

	double sumMass = 0;
	do {
	    sumMass += InputNumber("Ввод массы: ");
    } while (maxMass > sumMass);
Если сумма станет больше значения переменной «maxMass», то произойдёт выход из цикла с отображением текста о загрузке контейнера.

3. Запусти программу на выполнение и проверь её работоспособность, например, введя данные как на скриншоте выше.

Если у тебя возникли затруднения в написании кода, можешь просмотреть полную версию:


В данном примере у нас были известны как начальное значение переменной цикла (равное нулю), так и его конечное значение (равное значению в переменной «maxMass»), а вот шаг цикла был переменным (задавался с клавиатуры), поэтому алгоритм нельзя было реализовать, используя цикл «for».

Циклы с постусловием выполняют своё тело один раз в любом случае, т. к. проверка условия выполняется в конце цикла. Но бывают случаи, когда тело цикла нужно выполнять только тогда, когда в этом есть необходимость.

Допустим, есть следующая проблема: роботизированное устройство на изделие длины «L» наклеивает ленты длины «D» (длина изделия может меняться и измеряется заранее). Необходимо разработать алгоритм, чтобы определить, какая часть изделия осталась непокрыта лентой, чтобы вырезать ленту длиной «X» и наклеить её на оставшуюся часть:


Казалось бы, задача решается в одно действие:


Примечание: в математических обозначениях используемого типа скобки означают, что получившееся в них число округляется до ближайшего целого в меньшую сторону (отброс дробной части).

См. подробней: http://ru.wikipedia.org/wiki/Целая_часть.

Но проблема может заключатся в том, что большинство бюджетных микроконтроллеров, которые используются при проектировании роботизированных устройств, не умеют выполнять операцию деления, а некоторые даже умножения. Поэтому необходимо разработать алгоритм вычисления значения «X», используя только операции сложения и вычитания.

1. Создай новый проект, а в нём создай класс с именем «myClass».

2. Напиши программу, которая находит значение «Х» по введённым с клавиатуры значениям «L» и «D», используя только операции сложения и вычитания. Пример работы программы показан ниже.


Примечание: для ввода данных используй функцию «InputNumber», модифицированную в этом уроке.

Для вычисления значения «Х» необходимо из «L» вычитать значение «D» до тех пор, пока разница не станет меньше или равна «D». В этом случае как раз и будет необходим цикл с предусловием. Ведь если изначально значение «D» больше значения «L», то находить разность смысла не имеет.

В цикле с предусловием сначала проверяется условие выхода из цикла, а затем выполняется его тело.

В синтаксисе языка Java цикл с предусловием записывается следующим образом:

	<инициализация>
	while ( <условие продолжения цикла> ) {
	    <тело цикла с изменением переменной цикла>
	}
Этот цикл многократно выполняется до тех пор, пока значение логического выражения в условии равно «true», причём:

инициализация переменной цикла осуществляется перед циклом;
изменение значения переменной автоматически в цикле не предусмотрено (как у цикла с параметром), и программист должен не забыть прописать в теле цикла оператор, изменяющий переменную цикла.
Примечания:

Если изначально условие не выполняется, то тело цикла не будет выполнено ни разу.
Если ты забыл об изменении переменной цикла внутри тела цикла, то получишь бесконечный цикл.
Расчёт величины «Х» с помощью цикла с предусловием выглядит просто:

	double X = L;
	while ( X >= D) {
        X = X - D;
	}
Изначально предполагается, что значение «Х» равно длине изделия «L», а в теле цикла от «Х» отнимается значение ленты «D» до тех пор, пока «Х» не станет меньше «D».

3. Запусти программу на выполнение и проверь её работоспособность со следующими входными и выходными данными:

	L = 11, D = 3, X = 2; L = 4, D = 10, X = 4; L = 100, D = 23, X = 8.
Если у тебя возникли затруднения в написании кода, можешь просмотреть полный код функции «main»:


Цикл типа «for» всегда выполняется до тех пор, пока переменная цикла не достигла определённого значения. Но как быть, если в теле цикла уже найдено требуемое решение, а цикл ещё не завершил свою работу? В этом случае его можно прервать и не выполнять оставшиеся итерации «впустую».

Действительно, часто возникают задачи, когда при каком-то условии нужно досрочно прервать выполнение цикла или пропустить тело цикла (либо его часть) на какой-то итерации. Вспоминаем, что для этих целей существуют операторы «break» (пер. с англ. прервать) и «continue» (пер. с англ. продолжить) соответственно. В языке Java, как и в языке C, эти операторы могут применяться в теле любого из трёх типов циклов.

На рисунке ниже показана блок-схема с результатами действия операторов «break» (схема слева) и «continue» (схема справа) внутри циклов (цикл обозначен схематично, в виде прямоугольников, обозначающих его начало и окончание). Видно, что оператор «break» немедленно прекращает работу цикла, а оператор «continue» пропускает все операторы, что следуют за ним, и передаёт управление в начало цикла, после чего начинается выполнение следующей итерации.


4. Открой проект поиска корней уравнения из предыдущего урока и модифицируй программу таким образом, чтобы находились, допустим, только первые три корня.

Прежде всего, необходимо организовать счётчик решений. Для этого перед циклом нужно объявить переменную цикла (например, с именем «counter»):

    int counter = 1;
А при выполнении условия решения уравнения увеличивать счётчик:

	if ( i*i + j*j*j == k*k*k*k ) {
		System.out.println(i +"\t| "+ j + "\t| " + k);
		counter++;
	}
Теперь необходимо прервать все три цикла, когда найдётся три решения. Самый простой способ — это просто выйти из программы:

	 if ( i*i + j*j*j == k*k*k*k ) {
		System.out.println(i +"\t| "+ j + "\t| " + k);
		if (counter > 2) System.exit(0);
		counter++;
	}
Но в этом случае выполнение программы прервётся. И если в дальнейшем с корнями уравнения необходимо произвести какие-то операции, сделать это будет невозможно.

Поэтому лучше воспользоваться оператором прерывания цикла «break» и заменить условие выхода из цикла на следующее:

	if (counter > 2) break;
5. Запусти программу на выполнение и проверь её работоспособность.

Но что мы видим... Программа работает так же, как и прежде: выдаёт больше трёх корней.

Всё дело в том, что прерывается только внутренний цикл с переменной цикла «k». В результате выполнение передаётся во внешний цикл с переменной цикла «j», и итерации продолжаются. Поэтому необходимо прервать все три цикла.

Наиболее очевидное решение — это поставить условие в тело всех трёх циклов. Такое решение будет работать, но читаемость кода сильно пострадает. Поэтому разработчики Java ввели специальные метки, которыми можно маркировать циклы. И в операторе «break» можно указать, цикл с какой меткой необходимо прервать.

Синтаксис меток простой:

<Имя метки>:

А для перехода по метке необходимо написать:

break <Имя метки>;

Примечание: метки задаются по правилам записи идентификаторов.

Создай метку для внешнего цикла, например, с именем «ex»:
	ex: for (int i = 1; i <= 1000; i++)
В операторе «break» укажи, что прерывание цикла нужно выполнить именно по метке с именем «ex» :
	if (counter > 2) break ex;
Теперь оператор «break» будет «знать», что прервать нужно тот цикл, который помечен меткой с именем «ex».

6. Запусти программу на выполнение и проверь её работоспособность.

Если у тебя возникли какие-то затруднения в написании кода, можешь просмотреть полную версию:

